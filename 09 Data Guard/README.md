# Data Guard

## Prepare primary database

### Enable archive log
```
sqlplus / as sysdba
SELECT log_mode from v$database ;
ALTER SYSTEM SET log_archive_dest_1 = 'LOCATION=USE_DB_RECOVERY_FILE_DEST' scope=both;
ALTER SYSTEM SET LOG_ARCHIVE_DEST_STATE_2=ENABLE;
ALTER SYSTEM SET LOG_ARCHIVE_FORMAT='%t_%s_%r.arc' SCOPE=SPFILE;
ALTER SYSTEM SET REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE SCOPE=SPFILE;
shutdown immediate
startup mount
ALTER DATABASE ARCHIVELOG;
ALTER DATABASE OPEN;
ALTER SYSTEM SWITCH logfile;
SELECT name from v$archived_log;
SELECT log_mode from v$database ;
```

### Enable force logging
```
SELECT force_logging from v$database;
ALTER database force logging;
SELECT force_logging from v$database;
```

### Check redo log size
```
SELECT group#, thread#, bytes/1024/1024 mb from v$log;
SELECT thread#, instance from v$thread ;
```

### Create standby redo logs

untuk membuat standby redo log, pastikan kamu menggunakan size yang sama pada pengecheckan redo log size
disini karena saya memiliki 3 redo log dan size 200mb, maka saya buat dengan size dan jumlah segitu
```
ALTER database add standby logfile thread 1 size 200m;
ALTER database add standby logfile thread 1 size 200m;
ALTER database add standby logfile thread 1 size 200m;
```

### Check standby redo logs
```
SELECT group#, thread#, sequence#, bytes/1024/1024 mb, archived, status from v$standby_log;
SELECT member from v$logfile where type = 'STANDBY';
```

### Check db Unique Name
```
show parameter db_unique_name
```

### Set log_archive_config
pada bagian dg_config sesuaikan dengan unique name untuk primary dan standby server
```
ALTER SYSTEM set log_archive_config='DG_CONFIG=(ORCLDB,STBYDB)' scope=both;
```

### Set log_archive_dest_2
```
ALTER SYSTEM set log_archive_dest_2='SERVICE=STBYDB ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=STBYDB' scope=both;
```

### Set fal server
```
show parameter fal_server ;
ALTER SYSTEM set fal_server ='STBYDB' scope=both;
```

### Set standby_file_management
```
show parameter standby_file_management
ALTER SYSTEM set standby_file_management='AUTO' scope=both;
```

### Get a list of directory-dependent parameters and create the directories needed in the standby server:
```
SELECT name, value from v$parameter where upper(value) like upper('%/orcldb/%');
```
You will create the adump directory later on.

### Enable flashback
```
ALTER database flashback on;
```

### Check the password file
```
ls /opt/oracle/product/19c/dbhome_1/dbs/orapw*
```

### Edit file tnsname.ora
```
# tnsnames.ora Network Configuration File: /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.

LISTENER_ORCLDB =
  (ADDRESS = (PROTOCOL = TCP)(HOST = oracle1)(PORT = 1521))


ORCLDB =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = oracle1)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcldb)
    )
  )
STBYDB =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = oracle2)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = stbydb)
    )
  )
```


### Edit file listener.ora
```
# listener.ora Network Configuration File: /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora
# Generated by Oracle configuration tools.

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = oracle1)(PORT = 1521))
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
    )
  )

SID_LIST_LISTENER =
  (SID_LIST=
    (SID_DESC=
      (GLOBAL_DBNAME=orcldb)
      (SID_NAME=orcldb)
      (ORACLE_HOME=/opt/oracle/product/19c/dbhome_1)
    )
  )
```

### Reload listener
```
lsnrctl reload
```

## Prepare Standby database

### Create an init file with just the db_name
```
echo 'DB_NAME=ORCLDB' > $ORACLE_HOME/dbs/initstbydb.ora
```

### Copy password file from primary to standby
```
scp oracle@oracle1:/opt/oracle/product/19c/dbhome_1/dbs/orapw* /opt/oracle/product/19c/dbhome_1/dbs/orapwstbydb
```

### Copy tnsnames.ora
```
scp oracle@oracle1:/opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora
```

### Create listener
```
# listener.ora Network Configuration File: /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora
# Generated by Oracle configuration tools.

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = oracle2)(PORT = 1521))
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
    )
  )
SID_LIST_LISTENER=
   (SID_LIST=
        (SID_DESC=
          (GLOBAL_DBNAME=stbydb)
          (SID_NAME=stbydb)
          (ORACLE_HOME=/opt/oracle/product/19c/dbhome_1)
        )
      )
```

### Reload listener
```
lsnrctl start
lsnrctl reload
```

### Create the adump folder
```
mkdir -p /opt/oracle/admin/stbydb/adump
mkdir -p /opt/oracle/oradata/STBYDB/controlfile
mkdir -p /opt/oracle/fast_recovery_area
```

### start nomount
```
. oraenv
ORACLE_SID = [orcldb] ? stbydb
ORACLE_HOME = [/home/oracle] ? /opt/oracle/product/19c/dbhome_1
sqlplus / as sysdba
startup nomount
exit
```

### Duplicate database
connect to rman

connect to primary and standby database at the same time
```
rman target sys/Itnsa123@ORCLDB auxiliary sys/Itnsa123@STBYDB
```

duplicate database
```
DUPLICATE TARGET DATABASE FOR STANDBY FROM ACTIVE DATABASE DORECOVER
SPFILE
SET DB_UNIQUE_NAME 'STBYDB' COMMENT 'Is standby'
SET LOG_ARCHIVE_DEST_2 'SERVICE=ORCLDB ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=ORCLDB'
SET AUDIT_FILE_DEST '/opt/oracle/admin/stbydb/adump'
SET CONTROL_FILES '/opt/oracle/oradata/STBYDB/controlfile/control01.ctl'
SET FAL_SERVER 'ORCLDB'
NOFILENAMECHECK;
```

on standby server check
```
sqlplus / as sysdba
SELECT database_role from v$database;
show parameter db_name
show parameter db_unique_name
```

start redo apply process on standby 
```
ALTER database recover managed standby database disconnect from session;
```

check standby server is applying archivers
```
SELECT role, thread#, sequence#, action from v$dataguard_process;
```

Now go to the primary and check the archivers too and do a switch logfile to generate a new archiver
```
SELECT sequence#, first_time, next_time from v$archived_log order by sequence#;
ALTER SYSTEM switch logfile;
```

Now go to the standby database and check that the new archiver has been applied.
```
SELECT sequence#, first_time, next_time, applied from v$archived_log order by sequence#;
```

Stop the recovery process on the standby
```
ALTER database recover managed standby database cancel;
```

enable flashback on standby
```
ALTER database flashback on;
```

start recovery process on standby
```
ALTER database recover managed standby database disconnect from session;
```

## Switchover 
go to primary to verify swithcover
```
sqlplus / as sysdba
ALTER database switchover to STBYDB verify;
```

go to primary server check gap status
```
SELECT status, gap_status 
from v$archive_dest_status 
where dest_id = 2;
```

switchover to standby. jalankan pada primary database
```	
ALTER database switchover to STBYDB;
```

dont forget to open database in standby (now primary)
```
alter database open;
```

startup mount in srv1 (now is standby server)
```
startup mount
alter database recover managed standby database disconnect;
```

check status in srv1
```
select database_role from v$database;
select role, thread#, sequence#, action from v$dataguard_process;
```

### Switchover back

di srv2 yang telah menjadi primary server
```
ALTER database switchover to ORCLDB verify;
ALTER database switchover to ORCLDB;
```

open srv1
```
ALTER database open;
```

mount on srv2
```
startup mount
ALTER database recover managed standby database disconnect;
```

verify on all server
```
SELECT database_role from v$database;
```

### How to see gap
```
SELECT primary.thread#,
       primary.maxsequence primaryseq,
       standby.maxsequence standbyseq,
       primary.maxsequence - standby.maxsequence gap
from ( SELECT thread#, max(sequence#) maxsequence
       from v$archived_log
       where archived = 'YES'
         and resetlogs_change# = ( SELECT d.resetlogs_change# from v$database d )
       group by thread# order by thread# ) primary,
     ( SELECT thread#, max(sequence#) maxsequence
       from v$archived_log
       where applied = 'YES'
         and resetlogs_change# = ( SELECT d.resetlogs_change# from v$database d )
       group by thread# order by thread# ) standby
where primary.thread# = standby.thread#;
```


check mrp status
```
SELECT PROCESS, CLIENT_PROCESS, STATUS, THREAD#, SEQUENCE#, BLOCK#, BLOCKS FROM GV$MANAGED_STANDBY;
```

s